'use strict';
var __ = require('../functions/object');
/**
 * - [extendProto](#extendProto)
 * - [createSubclass](#createSubclass)
 * - [makeSubclass](#makeSubclass)
 * - [newApply](#newApply)
 *
 * These methods can be [chained](proto.js.html#Proto)
 */
var prototypeMethods = module.exports = {
    extendProto: extendProto,
    createSubclass: createSubclass,
    makeSubclass: makeSubclass,
    newApply: newApply
};
/**
 * Adds non-enumerable, non-configurable and non-writable properties to the prototype of constructor function.
 * Usage:
 * ```
 * function MyClass() {}
 * _.extendProto(MyClass, {
 *     method1: function() {},
 *     method2: function() {}
 * });
 * ```
 * To extend class via object:
 * ```
 * _.extendProto(obj.constructor, methods);
 * ```
 * Returns passed constructor, so functions _.extendProto, [_.extend](object.js.html#extend) and _.makeSubclass can be [chained](proto.js.html). 
 *
 * @param {Function} self constructor function
 * @param {Object} methods a map of functions, keys will be instance methods (properties of the constructor prototype)
 * @return {Function}
 */
function extendProto(self, methods) {
    var propDescriptors = {};
    var key;
    var keys = Object.getOwnPropertyNames(methods);
    for (var i = 0; i < keys.length; i++) {
        key = keys[i];
        propDescriptors[key] = {
            enumerable: false,
            configurable: false,
            writable: false,
            value: methods[key]
        };
    }
    Object.defineProperties(self.prototype, propDescriptors);
    return self;
}
/**
 * Makes a subclass of class `thisClass`.
 * The returned function will have specified `name` if supplied.
 * The constructor of superclass will be called in subclass constructor by default unless `applyConstructor === false` (not just falsy).
 * Copies `thisClass` class methods to created subclass. For them to work correctly they should use `this` to refer to the class rather than explicit superclass name.
 *
 * @param {Function} thisClass A class to make subclass of
 * @param {String} name Optional name of subclass constructor function
 * @param {Boolean} applyConstructor Optional false value (not falsy) to prevent call of inherited constructor in the constructor of subclass
 * @return {Function}
 */
function createSubclass(self, name, applyConstructor) {
    var subclass;
    // name is optional
    name = name || '';
    // apply superclass constructor
    var constructorCode = applyConstructor === false ? '' : 'self.apply(this, arguments);';
    var code = 'return function ' + name + '(){ ' + constructorCode + ' }';
    var subclass = (new Function('self', code))(self);
    // prototype chain
    subclass.prototype = Object.create(self.prototype);
    // subclass identity
    Object.defineProperty(subclass.prototype, 'constructor', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: subclass
    });
    // copy class methods
    // - for them to work correctly they should not explictly use superclass name
    // and use "this" instead
    __.deepExtend(subclass, self, true);
    return subclass;
}
/**
 * Sets up prototype chain to change `thisClass` (a constructor function) so that it becomes a subclass of `Superclass`.
 * Returns `thisClass` so it can be [chained](proto.js.html) with _.extendProto and [_.extend](object.js.html#extend).
 *
 * @param {Function} thisClass A class that will become a subclass of Superclass
 * @param {Function} Superclass A class that will become a superclass of thisClass
 * @return {Function}
 */
function makeSubclass(self, Superclass) {
    // prototype chain
    self.prototype = Object.create(Superclass.prototype);
    // subclass identity
    Object.defineProperty(self.prototype, 'constructor', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: self
    });
    return self;
}
/**
 * Calls constructor `this` with arguments passed as array
 * 
 * @param {Function} thisClass A class constructor that will be called
 * @return {Array} args Array of arguments that will be passed to constructor
 */
function newApply(self, args) {
    if (!Array.isArray(args)) args = Array.prototype.slice.call(args);
    // "null" is context to pass to class constructor, first parameter of bind
    var args = [null].concat(args);
    var obj = new(Function.prototype.bind.apply(self, args));
    return obj;
}

'use strict';
/**
 * - [extend](#extend)
 * - [clone](#clone)
 * - [defineProperty](#defineProperty)
 * - [defineProperties](#defineProperties)
 * - [deepExtend](#deepExtend)
 * - [deepClone](#deepClone)
 * - [keys](#keys)
 * - [allKeys](#allKeys)
 * - [values](#values)
 * - [keyOf](#keyOf)
 * - [allKeysOf](#allKeysOf)
 * - [eachKey](#eachKey)
 * - [mapKeys](#mapKeys)
 * - [reduceKeys](#reduceKeys)
 * - [filterKeys](#filterKeys)
 * - [someKey](#someKey)
 * - [everyKey](#everyKey)
 * - [findValue](#findValue)
 * - [findKey](#findKey)
 * - [pickKeys](#pickKeys)
 * - [omitKeys](#omitKeys)
 * - [isEqual](#isEqual)
 * - [isNot](#isNot)
 *
 * All these methods can be [chained](proto.js.html#Proto)
 */
module.exports = {
    extend: extend,
    clone: clone,
    findValue: findValue,
    findKey: findKey,
    defineProperty: defineProperty,
    defineProperties: defineProperties,
    deepExtend: deepExtend,
    deepClone: deepClone,
    keys: keys,
    allKeys: allKeys,
    values: values,
    keyOf: keyOf,
    allKeysOf: allKeysOf,
    eachKey: eachKey,
    mapKeys: mapKeys,
    reduceKeys: reduceKeys,
    filterKeys: filterKeys,
    someKey: someKey,
    everyKey: everyKey,
    pickKeys: pickKeys,
    omitKeys: omitKeys,
    isEqual: isEqual,
    isNot: isNot
};
var concat = Array.prototype.concat;
/**
 * ####Property descriptor constants####
 * The sum of these constants can be used as last parameter of defineProperty and defineProperties to determine types of properties.
 */
var constants = module.exports._constants = {
    ENUMERABLE: 1,
    ENUM: 1,
    CONFIGURABLE: 2,
    CONF: 2,
    WRITABLE: 4,
    WRIT: 4
};
/**
 * Extends object `self` with the properties of the object `obj` copying all own properties (not those inherited via prototype chain), including non-enumerable properties (unless `onlyEnumerable` is truthy).
 * Created properties will have the same descriptors as the propertis of `obj`.
 * Returns `self` to allow chaining with other functions.
 * Can be used with functions, to copy class methods, e.g.
 *
 * @param {Object} self An object to be extended
 * @param {Object} obj An object which properties will be copied to self
 * @param {Boolean} onlyEnumerable Optional flag to prevent copying non-enumerable properties, `false` by default
 * @return {Object}
 */
function extend(self, obj, onlyEnumerable) {
    var descriptors = {};
    var key;
    if (onlyEnumerable) {
        for (key in obj) {
            var desc = Object.getOwnPropertyDescriptor(obj, key);
            if (desc) descriptors[key] = desc;
        }
    } else {
        var keys = Object.getOwnPropertyNames(obj);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            var desc = Object.getOwnPropertyDescriptor(obj, key);
            if (desc) descriptors[key] = desc;
        }
    }
    Object.defineProperties(self, descriptors);
    return self;
}
/**
 * Makes a shallow clone of object `obj` creating an instance of the same class; the properties will have the same descriptors.
 * To clone an array use
 * ```
 * var clonedArray = [].concat(arr);
 * ```
 * This function should not be used to clone an array, because it is inefficient.
 *
 * @param {Object} self An object to be cloned
 * @param {Boolean} onlyEnumerable Optional flag to prevent copying non-enumerable properties, `false` by default
 * @return {Object}
 */
function clone(self, onlyEnumerable) {
    var clonedObject;
    if (Array.isArray(self)) clonedObject = self.slice();
    else if (self instanceof Date) clonedObject = new Date(self);
    else if (self instanceof RegExp) clonedObject = new RegExp(self);
    if (!clonedObject) {
        var descriptors = {};
        var key;
        if (onlyEnumerable) {
            for (key in self) {
                var desc = Object.getOwnPropertyDescriptor(self, key);
                if (desc) descriptors[key] = desc;
            }
        } else {
            var keys = Object.getOwnPropertyNames(self);
            for (var i = 0; i < keys.length; i++) {
                key = keys[i];
                var desc = Object.getOwnPropertyDescriptor(self, key);
                if (desc) descriptors[key] = desc;
            }
        }
        clonedObject = Object.create(self.constructor.prototype, descriptors);
    }
    return clonedObject;
}
/**
 * Analogue of ES6 [Array __find__ method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).
 * Returns the value of object property that passes callback test.
 *
 * @param {Object} self object to search in
 * @param {Function} callback should return `true` for item to pass the test, passed `value`, `key` and `self` as parameters
 * @param {Object} thisArg optional context (`this`) of callback call
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Any}
 */
function findValue(self, callback, thisArg, onlyEnumerable) {
    var result = undefined;
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            var item = self[key];
            if (callback.call(thisArg, item, key, self)) {
                result = item;
                break;
            }
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            var item = self[key];
            if (callback.call(thisArg, item, key, self)) {
                result = item;
                break;
            }
        }
    }
    return result;
}
/**
 * Analogue of ES6 [Array __findIndex__ method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).
 * Returns the key of object property that passes callback test. Returns `undefined` if not found (unlike `findIndex`, that returns -1 in this case).
 *
 * @param {Object} self object to search in
 * @param {Function} callback should return `true` for item to pass the test, passed `value`, `key` and `self` as parameters
 * @param {Object} thisArg optional context (`this`) of callback call
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Integer}
 */
function findKey(self, callback, thisArg, onlyEnumerable) {
    var result = undefined;
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            var item = self[key];
            if (callback.call(thisArg, item, key, self)) {
                result = key;
                break;
            }
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            var item = self[key];
            if (callback.call(thisArg, item, key, self)) {
                result = key;
                break;
            }
        }
    }
    return result;
}
/**
 * Syntax sugar to shorten usage of `Object.defineProperty`.
 * The simplest usage (to add non-enumerable, non-configurable, non-writable property):
 * ```
 * _.defineProperty(obj, 'key', value);
 * ```
 *
 * To define some other properties use sum of the flags `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`):
 * ```
 * _.defineProperty(obj, 'key', value, _.ENUM + _.WRIT);
 * ```
 * Returns `self`.
 *
 * @param {Object} self An object to add a property to
 * @param {String} propertyName the name of the property that will be added
 * @param {Any} value the value of added property
 * @param {Integer} decriptorFlags bit mask of property descriptor properties composed from `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`)
 * @return {Object}
 */
function defineProperty(self, propertyName, value, decriptorFlags) {
    var descriptor = {
        value: value
    };
    if (decriptorFlags) {
        descriptor.enumerable = !!(decriptorFlags & constants.ENUMERABLE);
        descriptor.configurable = !!(decriptorFlags & constants.CONFIGURABLE);
        descriptor.writable = !!(decriptorFlags & constants.WRITABLE);
    }
    Object.defineProperty(self, propertyName, descriptor);
    return self;
}
/**
 * Syntax sugar to shorten usage of `Object.defineProperties`.
 * The simplest usage (to add non-enumerable, non-configurable, non-writable properties):
 * ```
 * _.defineProperties(obj, {
 *     key1: value1,
 *     key2: value2
 * });
 * ```
 * To define some other properties use sum of the flags `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`):
 * ```
 * _.defineProperties(obj, {
 *     key1: value1,
 *     key2: value2
 * }, _.ENUM + _.WRIT);
 * ```
 * Returns `self`.
 *
 * @param {Object} self An object to add a property to
 * @param {Object} propertyValues A map of keys and values of properties thatwill be added. The descriptors of properties will be defined by the following parameters.
 * @param {Integer} decriptorFlags bit mask of property descriptor properties composed from `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`)
 * @return {Object}
 */
function defineProperties(self, propertyValues, decriptorFlags) {
    var descriptors = {};
    var key;
    var keys = Object.getOwnPropertyNames(propertyValues);
    for (var i = 0; i < keys.length; i++) {
        key = keys[i];
        var value = propertyValues[key];
        var descriptor = {
            value: value
        };
        if (decriptorFlags) {
            descriptor.enumerable = !!(decriptorFlags & constants.ENUMERABLE);
            descriptor.configurable = !!(decriptorFlags & constants.CONFIGURABLE);
            descriptor.writable = !!(decriptorFlags & constants.WRITABLE);
        }
        descriptors[key] = descriptor;
    }
    Object.defineProperties(self, descriptors);
    return self;
}
/**
 * Extends object `self` with properties of `obj` to any depth, without overwrtiting existing object properties of `self` with object properties of `obj`.
 * Scalar properties of `obj` will overwrite properties of `self`. Scalar porperties of `self` will also be overwritten.
 * Correctly works with recursive objects.
 * Usage:
 * ```
 * var obj = {
 *     inner: {
 *         a: 1
 *     }
 * };
 *
 * _.deepExtend(obj, {
 *     inner: {
 *         b: 2
 *     }
 * });
 *
 * assert.deepEqual(obj, {
 *     inner: {
 *         a: 1,
 *         b: 2
 *     }
 * }); // assert passes
 * ```
 * Returns `self`.
 *
 * @param {Object} self An object to be extended
 * @param {Object} obj An object with properties to copy to
 * @param {Boolean} onlyEnumerable Optional `true` to use only enumerable properties
 * @param {Boolean} preserveStructure if true will throw at the attempt to overwrite object with scalar value (including Date and Regex) and vice versa
 * @return {Object}
 */
function deepExtend(self, obj, onlyEnumerable, preserveStructure) {
    var result = _extendTree(self, obj, onlyEnumerable, preserveStructure, []);
    return result;
}

function _extendTree(selfNode, objNode, onlyEnumerable, preserveStructure, objTraversed) {
    if (objTraversed.indexOf(objNode) >= 0) return selfNode; // node already traversed, obj has recursion
    // store node to recognise recursion
    objTraversed.push(objNode);
    if (Array.isArray(objNode)) {
        for (var key = 0; key < objNode.length; key++) {
            var value = objNode[key];
            var hasProp = selfNode.hasOwnProperty(key);
            var selfValue = selfNode[key];
            var isSelfObj = typeof selfValue == "object" && selfValue != null && !(selfValue instanceof RegExp) && !(selfValue instanceof Date);
            var isValueObj = typeof value == "object" && value != null && !(value instanceof RegExp) && !(value instanceof Date);
            if (preserveStructure && hasProp && isSelfObj != isValueObj) throw new Error("deepExtend");
            if (isValueObj) {
                if (!hasProp || !isSelfObj) selfNode[key] = (Array.isArray(value)) ? [] : {};
                _extendTree(selfNode[key], value, onlyEnumerable, preserveStructure, objTraversed);
            } else {
                var descriptor = Object.getOwnPropertyDescriptor(objNode, key);
                if (descriptor) Object.defineProperty(selfNode, key, descriptor);
            }
        }
    } else {
        var key;
        if (onlyEnumerable) {
            for (key in objNode) {
                var value = objNode[key];
                var hasProp = selfNode.hasOwnProperty(key);
                var selfValue = selfNode[key];
                var isSelfObj = typeof selfValue == "object" && selfValue != null && !(selfValue instanceof RegExp) && !(selfValue instanceof Date);
                var isValueObj = typeof value == "object" && value != null && !(value instanceof RegExp) && !(value instanceof Date);
                if (preserveStructure && hasProp && isSelfObj != isValueObj) throw new Error("deepExtend");
                if (isValueObj) {
                    if (!hasProp || !isSelfObj) selfNode[key] = (Array.isArray(value)) ? [] : {};
                    _extendTree(selfNode[key], value, onlyEnumerable, preserveStructure, objTraversed);
                } else {
                    var descriptor = Object.getOwnPropertyDescriptor(objNode, key);
                    if (descriptor) Object.defineProperty(selfNode, key, descriptor);
                }
            }
        } else {
            var keys = Object.getOwnPropertyNames(objNode);
            for (var i = 0; i < keys.length; i++) {
                key = keys[i];
                var value = objNode[key];
                var hasProp = selfNode.hasOwnProperty(key);
                var selfValue = selfNode[key];
                var isSelfObj = typeof selfValue == "object" && selfValue != null && !(selfValue instanceof RegExp) && !(selfValue instanceof Date);
                var isValueObj = typeof value == "object" && value != null && !(value instanceof RegExp) && !(value instanceof Date);
                if (preserveStructure && hasProp && isSelfObj != isValueObj) throw new Error("deepExtend");
                if (isValueObj) {
                    if (!hasProp || !isSelfObj) selfNode[key] = (Array.isArray(value)) ? [] : {};
                    _extendTree(selfNode[key], value, onlyEnumerable, preserveStructure, objTraversed);
                } else {
                    var descriptor = Object.getOwnPropertyDescriptor(objNode, key);
                    if (descriptor) Object.defineProperty(selfNode, key, descriptor);
                }
            }
        }
    }
    objTraversed.pop();
    return selfNode;
}
/**
 * Clones all object tree. Class of original object is not preserved. Returns `self`
 *
 * @param {Object} self An object to be extended
 * @param {Boolean} onlyEnumerable Optional `true` to use only enumerable properties
 * @return {Object}
 */
function deepClone(self, onlyEnumerable) {
    var clonedObject;
    if (self instanceof Date) clonedObject = new Date(self);
    else if (self instanceof RegExp) clonedObject = new RegExp(self);
    else {
        clonedObject = Array.isArray(self) ? [] : {};
        _extendTree(clonedObject, self, onlyEnumerable, false, []);
    }
    return clonedObject;
}
/**
 * Returns array of enumerable properties of the object
 *
 * @param {Object} self object to return keys of
 * @return {Array}
 */
function keys(self) {
    var keys = Object.keys(self);
    return keys;
}
/**
 * Returns array of all property names of an object `self` (including non-enumerbale).
 * To get only enumerable properties, use `Object.keys()`.
 *
 * @param {Object} self An object to get all properties of.
 * @return {Array}
 */
function allKeys(self) {
    var keys = Object.getOwnPropertyNames(self);
    return keys;
}
/**
 * Returns array of values of the object's keys
 *
 * @param {Object} self object to return values from
 * @return {Array}
 */
function values(self, onlyEnumerable) {
    var arr = [];
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            arr[arr.length] = self[key];
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            arr[arr.length] = self[key];
        }
    }
    return arr;
}
/**
 * An analogue of `indexOf` method of Array prototype.
 * Returns the `key` of `searchElement` in the object `self`.
 * As object keys are unsorted, if there are several keys that hold `searchElement` any of them can be returned. Use `allKeysOf` to return all keys.
 * All own properties are searched (not those inherited via prototype chain), including non-enumerable properties (unless `onlyEnumerable` is truthy).
 *
 * @param {Object} self An object to search a value in
 * @param {Any} searchElement An element that will be searched. An exact equality is tested, so `0` is not the same as `'0'`.
 * @param {Boolean} onlyEnumerable An optional true to search among enumerable properties only.
 * @return {String}
 */
function keyOf(self, searchElement, onlyEnumerable) {
    var foundKey;
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            if (searchElement === self[key]) {
                foundKey = key;
                break;
            }
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            if (searchElement === self[key]) {
                foundKey = key;
                break;
            }
        }
    }
    return foundKey;
}
/**
 * Works similarly to the previous function, but returns the array of keys holding `searchElement` as their value.
 *
 * @param {Object} self An object to search a value in
 * @param {Any} searchElement An element that will be searched. An exact equality is tested, so `0` is not the same as `'0'`.
 * @param {Boolean} onlyEnumerable An optional true to search among enumerable properties only.
 * @return {Array<String>}
 */
function allKeysOf(self, searchElement, onlyEnumerable) {
    var foundKeys = [];
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            if (searchElement === self[key]) {
                foundKeys[foundKeys.length] = key;
            }
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            if (searchElement === self[key]) {
                foundKeys[foundKeys.length] = key;
            }
        }
    }
    return foundKeys;
}
/**
 * An analogue of [forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) method of Array prototype.
 * Iterates all own properties of `self` (or only enumerable own properties if `onlyEnumerable` is truthy) calling callback for each key.
 * This method should not be used with arrays, it will include `length` property in iteration.
 * To iterate array-like objects (e.g., `arguments` pseudo-array) use:
 * ```
 * _.forEach(arguments, callback, thisArg);
 * ```
 * Function returns `self` to allow [chaining](proto.js.html)
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `value`, `key` and `self`, its return value is not used.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 */
function eachKey(self, callback, thisArg, onlyEnumerable) {
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            callback.call(thisArg, self[key], key, self);
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            callback.call(thisArg, self[key], key, self);
        }
    }
    return self;
}
/**
 * An analogue of [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) method of Array prototype.
 * Returns the object that is the result of the application of callback to values in all own properties of `self` (or only enumerable own properties if `onlyEnumerable` is truthy).
 * The returned object will be the instance of the same class as `self`.
 * Property descriptors of the returned object will have the same `enumerable`, `configurable` and `writable` settings as the properties of `self`.
 * This method should not be used with arrays, it will include `length` property in iteration.
 * To map array-like objects use:
 * ```
 * var result = _.map(arguments, callback, thisArg);
 * ```
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `value`, `key` and `self` and should return value that will be included in the map.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Object}
 */
function mapKeys(self, callback, thisArg, onlyEnumerable) {
    var descriptors = {};
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            descriptors[key] = Object.getOwnPropertyDescriptor(self, key);
            descriptors[key].value = callback.call(thisArg, self[key], key, self);
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            descriptors[key] = Object.getOwnPropertyDescriptor(self, key);
            descriptors[key].value = callback.call(thisArg, self[key], key, self);
        }
    }
    var obj = Object.create(self.constructor.prototype, descriptors);
    return obj;
}
/**
 * An analogue of [reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) method of Array prototype.
 * This method reduces the object to a single value. Iteration order is impossible to control with object.
 * This method should not be used with arrays, it will include `length` property in iteration.
 * To reduce array-like objects use:
 * ```
 * var result = _.reduce(arguments, callback, initialValue, thisArg);
 * ```
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `previousValue`, `value`, `key` and `self` and should return value that will be used as the `previousValue` for the next `callback` call.
 * @param {Any} initialValue The initial value passed to callback as the first parameter on the first call.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Any}
 */
function reduceKeys(self, callback, initialValue, thisArg, onlyEnumerable) {
    var memo = initialValue;
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            memo = callback.call(thisArg, memo, self[key], key, self);
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            memo = callback.call(thisArg, memo, self[key], key, self);
        }
    }
    return memo;
}
/**
 * An analogue of [filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) method of Array prototype.
 * Returns the new object with keys for which callback returns true.
 * Property descriptors of the returned object will have the same `enumerable`, `configurable` and `writable` settings as the properties of `self`.
 * To filter array-like objects use:
 * ```
 * var result = _.filter(arguments, callback, thisArg);
 * ```
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `value`, `key` and `self`. If it returns truthy value, the key/value will be included in the resulting object.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Object}
 */
function filterKeys(self, callback, thisArg, onlyEnumerable) {
    var descriptors = {};
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            if (callback.call(thisArg, self[key], key, self)) descriptors[key] = Object.getOwnPropertyDescriptor(self, key);
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            if (callback.call(thisArg, self[key], key, self)) descriptors[key] = Object.getOwnPropertyDescriptor(self, key);
        }
    }
    var obj = Object.create(self.constructor.prototype, descriptors);
    return obj;
}
var _passed = {},
    _didNotPass = {};
/**
 * An analogue of [some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method of Array prototype.
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `value`, `key` and `self`. If it returns truthy value, the function immeaditely returns `true`.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Boolean}
 */
function someKey(self, callback, thisArg, onlyEnumerable) {
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            if (callback.call(thisArg, self[key], key, self)) return true;
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            if (callback.call(thisArg, self[key], key, self)) return true;
        }
    }
    return false;
}
/**
 * An analogue of [every](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every) method of Array prototype.
 *
 * @param {Object} self An object which properties will be iterated
 * @param {Function} callback Callback is passed `value`, `key` and `self`. If it returns falsy value, the function immeaditely returns `false`.
 * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.
 * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.
 * @return {Boolean}
 */
function everyKey(self, callback, thisArg, onlyEnumerable) {
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            if (!callback.call(thisArg, self[key], key, self)) return false;
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            if (!callback.call(thisArg, self[key], key, self)) return false;
        }
    }
    return true;
}
/**
 * Returns object of the same class with only specified keys, that are passed as string parameters or array(s) of keys.
 *
 * @param {Object} self an object to pick keys from
 * @param {List<String|Array>} arguments list of keys (or array(s) of keys)
 * @return {Object}
 */
function pickKeys(self) { // , ... keys
    var keys = concat.apply(Array.prototype, arguments);
    var obj = Object.create(self.constructor.prototype);
    for (var i = 1; i < keys.length; i++) {
        var key = keys[i];
        if (self.hasOwnProperty(key)) obj[key] = self[key];
    }
    return obj;;
}
/**
 * Returns object of the same class without specified keys, that are passed as string parameters or array(s) of keys.
 *
 * @param {Object} self an object to omit keys in
 * @param {List<String|Array>} arguments list of keys (or array of keys)
 * @return {Object}
 */
function omitKeys(self) { // , ... keys
    var clonedObject, onlyEnumerable;
    var descriptors = {};
    var key;
    if (onlyEnumerable) {
        for (key in self) {
            var desc = Object.getOwnPropertyDescriptor(self, key);
            if (desc) descriptors[key] = desc;
        }
    } else {
        var keys = Object.getOwnPropertyNames(self);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            var desc = Object.getOwnPropertyDescriptor(self, key);
            if (desc) descriptors[key] = desc;
        }
    }
    clonedObject = Object.create(self.constructor.prototype, descriptors);
    var keys = concat.apply(Array.prototype, arguments);
    for (var i = 1; i < keys.length; i++) {
        delete clonedObject[keys[i]];
    }
    return clonedObject;;
}
/**
 * Performs deep equality test of the object. Does not work with recursive objects
 * @param  {Any} self object to compare
 * @param  {Any} obj object to compare
 * @return {Boolean}
 */
function isEqual(self, obj) {
    var result;
    if (self === obj) {
        result = self !== 0 || 1 / self == 1 / obj; // 0 and -0 are considered not equal, although 0 === -0 is true
        return result;
    }
    if (self == null || obj == null) {
        return false;
    }
    var className = self.constructor.name;
    if (className != obj.constructor.name) {
        return false;
    }
    switch (className) {
        case 'String':
            result = self == String(obj);
            break;
        case 'Number':
            result = self != +self ? obj != +obj : (self == 0 ? 1 / self == 1 / obj : self == +obj);
            break;
        case 'Date':
        case 'Boolean':
            result = +self == +obj;
            break;
        case 'RegExp':
            result = self.source == obj.source && self.global == obj.global && self.multiline == obj.multiline && self.ignoreCase == obj.ignoreCase;
            break;
        default:
            if (typeof self != 'object' || typeof obj != 'object') {
                return false;
            }
            if (Array.isArray(self)) {
                if (self.length != obj.length) {
                    return false;
                }
                for (var i = 0; i < self.length; i++) {
                    result = isEqual(self[i], obj[i]);
                    if (!result) {
                        return false;
                    }
                }
                return true;
            } else {
                if (Object.getOwnPropertyNames(self).length != Object.getOwnPropertyNames(obj).length) {
                    return false;
                }
                result = true;
                var key;
                var keys = Object.getOwnPropertyNames(self);
                for (var i = 0; i < keys.length; i++) {
                    key = keys[i];
                    result = isEqual(self[key], obj[key]);
                    if (!result) break;
                }
                return result;
            }
    }
    return result;
}
/**
 * The opposite of isEqual
 * @param  {Any} self object to compare
 * @param  {Any} obj object to compare
 * @return {Boolean}
 */
function isNot(self, obj) {
    var equal = !isEqual(self, obj);
    return equal;
}
